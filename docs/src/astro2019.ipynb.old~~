{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<!-- dom:TITLE: Tutoriel: Apprendre l'Astronomie avec Python -->\n",
    "# Tutoriel: Apprendre l'Astronomie avec Python\n",
    "<!-- dom:AUTHOR: Ahmed Ammar Email:ahmed.ammar@fst.utm.tn at Faculté des Sciences, Université de Tunis El Manar et Société Astronomique de Tunisie. -->\n",
    "<!-- Author: -->  \n",
    "**Ahmed Ammar** (email: `ahmed.ammar@fst.utm.tn`), Faculté des Sciences, Université de Tunis El Manar et Société Astronomique de Tunisie.\n",
    "\n",
    "Date: **2019**\n",
    "\n",
    "# Python\n",
    "[Python](http://www.python.org/) est un langage de programmation moderne de haut niveau, orienté objet et d'usage général.\n",
    "\n",
    "**Caractéristiques générales de Python** :\n",
    "\n",
    "* Langage simple:\n",
    "\n",
    "  * facile à lire et à apprendre avec une syntaxe minimaliste.\n",
    "\n",
    "\n",
    "* Langage concis et expressif:\n",
    "\n",
    "  * moins de lignes de code\n",
    "\n",
    "  * moins de bugs\n",
    "\n",
    "  * plus facile à maintenir.\n",
    "\n",
    "\n",
    "**Détails techniques** :\n",
    "\n",
    "* Typé dynamiquement:\n",
    "\n",
    "  * Pas besoin de définir le type des variables, les arguments ou le type des fonctions.\n",
    "\n",
    "\n",
    "* La gestion automatique de la mémoire:\n",
    "\n",
    "  * Aucune nécessité d'allouer explicitement et désallouer la mémoire pour les variables et les tableaux de données. Aucun bug de fuite de mémoire.\n",
    "\n",
    "\n",
    "* Interprété:\n",
    "\n",
    "  * Pas besoin de compiler le code. L'interpréteur Python lit et exécute le code python directement.\n",
    "\n",
    "\n",
    "**Avantages** :\n",
    "\n",
    "* Le principal avantage est la facilité de programmation, qui minimise le temps nécessaire pour développer, déboguer et maintenir le code.\n",
    "\n",
    "* Langage bien conçu qui encourage les bonnes pratiques de programmation:\n",
    "\n",
    "  * Modulaire et orientée objet, permet l'encapsulation  et la réutilisation de code. Il en résulte souvent un code plus transparent, plus facile à améliorer et sans bug.\n",
    "\n",
    "  * Documentation intégré avec le code.\n",
    "\n",
    "\n",
    "* De nombreuses bibliothèques standards, et de nombreux packages add-on.\n",
    "\n",
    "<!-- dom:FIGURE: [figs/python_easy.png, width=600 frac=0.6] -->\n",
    "<!-- begin figure -->\n",
    "\n",
    "<p></p>\n",
    "<img src=\"figs/python_easy.png\" width=600>\n",
    "\n",
    "<!-- end figure -->\n",
    "\n",
    "\n",
    "\n",
    "# Installation d'un environnement Python scientifique\n",
    "\n",
    "## Installation sur ordinateur\n",
    "\n",
    "### Qu’est ce que Anaconda ?\n",
    "\n",
    "L’installation d’un environnement Python complet peut-être une vraie galère. Déjà, il faut télécharger Python et l’installer. Par la suite, télécharger un à un les packages dont on a besoin. Parfois, le nombre de ces librairies peut-être grand.\n",
    "\n",
    "Par ailleurs, il faut s’assurer de la compatibilité entre les versions des différentes packages qu’on a à télécharger. Bref, ce n’est pas amusant.\n",
    "\n",
    "[Anaconda](https://www.anaconda.com/download/) est  une distribution Python. A son installation, Anaconda installera Python ainsi qu'une multitude de packages (voir [liste de packages anaconda](https://docs.anaconda.com/anaconda/packages/pkg-docs#python-3-6)).  Cela nous évite de nous ruer dans les problèmes d’incompatibilités entre les différents packages.\n",
    "\n",
    "Finalement, Anaconda propose un outil de gestion de packages appelé [conda](https://conda.io/docs/). Ce dernier permettra de mettre à jour et installer facilement les librairies dont on aura besoin pour nos développements.\n",
    "\n",
    "### Préparer la formation: téléchargement d’Anaconda\n",
    "\n",
    "Nous demandons à tous les étudiants de télécharger Anaconda. Pour cela, il faut télécharger un installeur à partir de <https://www.anaconda.com/download/>, correspondant à votre système d’exploitation (Windows, Mac OS X, Linux). Il faut choisir entre 32 bits ou 64 bits (pour la version *Python 3*) selon que votre système d’exploitation est 32 bits ou 64 bits.\n",
    "\n",
    "<!-- dom:FIGURE: [figs/AnacondaNavigator.png, width=600 frac=0.7] Interface graphique du navigateur Anaconda sur Windows -->\n",
    "<!-- begin figure -->\n",
    "\n",
    "<p>Interface graphique du navigateur Anaconda sur Windows</p>\n",
    "<img src=\"figs/AnacondaNavigator.png\" width=600>\n",
    "\n",
    "<!-- end figure -->\n",
    "\n",
    "\n",
    "**Remarque.**\n",
    "\n",
    "Anaconda installe plusieurs exécutables pour développer en Python dans le répertoire *anaconda/bin*, sans toujours créer des raccourcis sur le bureau ou dans un menu. Nous nous occuperons au tout début de la formation de créer des raccourcis pour pouvoir lancer l'application web *Jupyter notebook*. Vous pouvez lancer le notebook depuis le navigateur Anaconda.\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "## Installation sur smartphone\n",
    "\n",
    "### Pydroid 3 - IDE éducatif pour Python 3\n",
    "\n",
    "Pydroid 3 est l'IDE éducatif Python 3 le plus simple et le plus puissant à utiliser pour Android.\n",
    "\n",
    "Pydroid 3 fournit:\n",
    "\n",
    "* Interpréteur Python 3.6 hors connexion: Internet n'est pas nécessaire pour exécuter des programmes Python.\n",
    "\n",
    "* Pip package manager et un référentiel personnalisé pour les packages de roues prédéfinis pour les bibliothèques scientifiques améliorées, tels que numpy, scipy, matplotlib, scikit-learn et jupyter.\n",
    "\n",
    "* ...\n",
    "\n",
    "**Installer et utiliser Pydroid 3 sur son smartphone:**\n",
    "\n",
    "Pydroid est une application Android que vous pouvez obtenir sur Google Play: <https://play.google.com/store/apps/details?id=ru.iiec.pydroid3>\n",
    "\n",
    "Les étapes suivantes, dans les figures ci-dessous, vous permettent d’utiliser le cahier Jupyter sur votre téléphone portable n’importe où et à tout moment pour vous entraîner au maximum et vous familiariser avec tous les exemples de programmation de ce cours.\n",
    "\n",
    "**Phase installation:**\n",
    "\n",
    "1. Installer Pydroid 3 depuis Google Play: <https://play.google.com/store/apps/details?id=ru.iiec.pydroid3>\n",
    "\n",
    "2. Ouvrez l'application, sur le menu cliquez sur pip et allez à l'onglet \"QUICK INSTALL\" pour obtenir les bibliothèques scientifiques nécessaires à ce cours.\n",
    "\n",
    "3. Dans \"QUICK INSTALL\", installer les packages *Jupyter* , *numpy* et *matplotlib*.\n",
    "\n",
    "<!-- dom:FIGURE: [figs/pydroid3_1.png, width=600 frac=0.7] Pydroid 3: Phase installation -->\n",
    "<!-- begin figure -->\n",
    "\n",
    "<p>Pydroid 3: Phase installation</p>\n",
    "<img src=\"figs/pydroid3_1.png\" width=600>\n",
    "\n",
    "<!-- end figure -->\n",
    "\n",
    "\n",
    "**Phase utilisation:**\n",
    "\n",
    "4. Retournez au menu et ouvrez le **terminal**.\n",
    "\n",
    "5. Sur le terminal, entrez la commande suivante:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "        jupyter notebook\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "6. Jupyter s'exécutera sur votre navigateur Web. Accédez au répertoire dans lequel vous avez des notebooks à ouvrir, à télécharger (bouton *upload*) ou à créer (bouton *New*).\n",
    "\n",
    "7. Amusez-vous à travailler sur le notebook: créez du contenu, lancez et modifiez des exemples\n",
    "\n",
    "<!-- dom:FIGURE: [figs/pydroid3_2.png, width=600 frac=0.7] Pydroid 3: Phase utilisation -->\n",
    "<!-- begin figure -->\n",
    "\n",
    "<p>Pydroid 3: Phase utilisation</p>\n",
    "<img src=\"figs/pydroid3_2.png\" width=600>\n",
    "\n",
    "<!-- end figure -->\n",
    "\n",
    "\n",
    "# PyEphem\n",
    "Le module **PyEphem** (<https://rhodesmill.org/pyephem/>) vous permet d'effectuer de nombreux calculs astronomiques professionnels. Vous pouvez l'utiliser:\n",
    "* calculer les positions du soleil, de la lune, des planètes et de leurs lunes.\n",
    "\n",
    "* déterminer l'emplacement actuel des astéroïdes, des comètes et des satellites artificiels (fournir des éléments orbitaux).\n",
    "\n",
    "* déterminer le lever et le coucher du soleil d'objets divers en fonction de la position de l'observateur à la surface de la Terre.\n",
    "\n",
    "* trouver dans quelle constellation l'objet est.\n",
    "\n",
    "* calculer la position de étoiles, galaxies, etc.\n",
    "\n",
    "**PyEphem** est basé sur des procédures écrites pour le programme **XEphem** (<www.clearskyinstitute.com/xephem/>), disponible depuis de nombreuses années pour les utilisateurs du système *Unix*.\n",
    "\n",
    "## Installation\n",
    "La version 3.7.6.0 est la version la plus récente de PyEphem.\n",
    "<!-- dom:FIGURE: [figs/pyephem.png, width=500 frac=0.3] -->\n",
    "<!-- begin figure -->\n",
    "\n",
    "<p></p>\n",
    "<img src=\"figs/pyephem.png\" width=500>\n",
    "\n",
    "<!-- end figure -->\n",
    "\n",
    "Le moyen le plus simple d’installer PyEphem sur un ordinateur Window, Linux ou Mac OS, après s’être assuré que la distribution Python **Anaconda** est bien installée, est d'utiliser la commande `pip`, comme ceci:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "```\n",
    "        $ pip install pyephem\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Importation de module et lieu de l'observateur\n",
    "Le module **PyEphem** est disponible sous le nom **ephem** qui peut être modifié lors de l’importation par l'alias **ep** pour raccourcir la programmation."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "import ephem as ep\n",
    "#OBSERVATEUR\n",
    "obs = ep.Observer()\n",
    "# nous créons une structure dans laquelle des données\n",
    "# sur la position de l'observateur seront stockées\n",
    "obs.lon = \"10.00\"\n",
    "obs.lat = \"36.5\"\n",
    "obs.name = \"SAT-Tunis\"\n",
    "obs.elevation = 100.0"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Les fonctions et les structures du module `ephem ` sont appelées dans la fonction `ep.method()`. Tout d'abord, nous définissons la position de l'observateur. Pour ce faire, nous créons la structure appropriée (`structure = ep.Observer()`) et remplissons ses champs (`structure.champ = valeur`).\n",
    "\n",
    "## Objets célestes et leur localisation\n",
    "Tous les objets célestes importants tels que le Soleil, la Lune, les planètes et leurs lunes peuvent être créés par la structure de `fonction = ep.NomObjet()`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "# Objets\n",
    "# nous créons une structure dans laquelle les données seront stockées\n",
    "lune = ep.Moon()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Après avoir créé l'objet, nous pouvons calculer son emplacement actuel en fournissant des informations sur l'observateur, situées dans la structure `obs` précédemment créée."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "# CALCULS\n",
    "# on calcule la position actuelle de l'objet\n",
    "# pour l'observateur créé plus tôt\n",
    "lune.compute(obs)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Comme vous pouvez le constater, vous pouvez définir plusieurs observateurs différents et compter les coordonnées de l'objet sélectionné pour différents endroits de la Terre. Cela peut être utile lors de la planification de campagnes d’observation menées par différents observatoires.\n",
    "\n",
    "## Lecture de coordonnées\n",
    "\n",
    "Les coordonnées calculées sont lues à partir des champs de structure d'objet."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "# coordonnées calculées\n",
    "print(\"Position actuelle de la Lune\")\n",
    "print(\" ------------------------------ \")\n",
    "# nous affichons l'ascension droite et la déclinaison\n",
    "print(\"RA : \", lune.ra)\n",
    "print(\"Dec : \", lune.dec)\n",
    "# nous affichons l'azimut et l'élévation\n",
    "print(\"--------------------------------\")\n",
    "print(\"Az : \", lune.az)\n",
    "print (\"El : \" , lune.alt)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Les valeurs calculées sont données au format *_heures: minutes: secondes_* ou *_degrés: minutes: secondes d'arc_* pour l'heure actuelle UT sur époque 2000."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "        Position actuelle de la Lune\n",
    "         ------------------------------\n",
    "        RA :  6:18:27.81\n",
    "        Dec :  20:49:04.9\n",
    "        --------------------------------\n",
    "        Az :  197:06:32.3\n",
    "        El :  56:50:39.8\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Coordonnées en degrés\n",
    "Toutes les coordonnées calculées par les procédures du module **PyEphem** sont données en **radians**. lorsque nous voulons écrire leur valeur, par exemple, les radians sont automatiquement convertis au format approprié (heures, minutes, secondes dans le cas d'une ascension droite ou degrés, minutes, secondes d'arc pour d'autres coordonnées).\n",
    "\n",
    "Si vous souhaitez utiliser des coordonnées calculées sur un graphique, il est utile de les convertir en degrés à l'aide de la fonction degrés."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "# coordonnées azimutales en degrés sous forme d'un nombre réel\n",
    "print(\" -------------------------------- \")\n",
    "print(\"Az (deg): \", degrees(lune.az))\n",
    "print(\"El (deg): \", degrees(lune.alt))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Azimut et élévation en degrés:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "        --------------------------------\n",
    "        Az (deg):  207.85208210454263\n",
    "        El (deg):  55.334644372169485\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Date et heure\n",
    "\n",
    "Nous pouvons attribuer n'importe quelle date et heure à chaque observateur:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "# PROPRE DATE ET HEURE TU\n",
    "obs.date = \"2019/01/13 10:00:00\""
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Il faut seulement se rappeler que les chiffres de la date sont séparés par le signe `/` et l'heure par deux points.\n",
    "\n",
    "## Mouvement apparent du Soleil - le début du programme"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "# IMPORTATION\n",
    "from pylab import *\n",
    "import ephem as ep\n",
    "# OBSERVATEUR\n",
    "obs = ep.Observer()\n",
    "# TUNIS\n",
    "obs.lon, obs.lat, obs.elev = '10.08', '36.4', 100.0\n",
    "obs.name= \"SAT-TUNIS\"\n",
    "# OBJET\n",
    "soleil = ep.Sun()\n",
    "# TEMPS\n",
    "tm = linspace(0 , 24 , 25)\n",
    "# GRAPHIQUE\n",
    "pt = subplot(111 , polar= True )"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Mouvement apparent du Soleil - solstice d'été"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "# BOUCLE PRINCIPALE\n",
    "for t in tm :\n",
    "    # changement de temps\n",
    "    obs.date = \"2014/06/21 %02 d :00:00 \"%t\n",
    "    # on calcule les coordonnées\n",
    "    sun.compute(obs)\n",
    "    # coordonnées azimutales - azimut en radians\n",
    "    az = float(repr(sun.az))\n",
    "    el = degrees(float(repr(sun.alt)))\n",
    "    # graphique - on change l'élévation par une distance zénithale\n",
    "    pt.plot([az], [90 - el], ls =\" \", marker= \" o \", c =\" yellow \", \\\n",
    "    markersize =10)\n",
    "    # heure locale UTC +2 heures en été\n",
    "    if el > 0:\n",
    "        pt.text (az, 90 - el, \" %02 d \"%(t+2), fontsize =10, \\\n",
    "        ha = 'left' , va = 'center')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Mouvement apparent du Soleil - solstice d'hiver"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "    # TRANSFERT HIVERNAL - nous répétons les calculs \"en décembre\"\n",
    "    obs.date = \"2014/12/22 %02d:00:00\" % t\n",
    "    soleil.compute(obs)\n",
    "    az = float(repr(soleil.az))\n",
    "    el = degrees(float(repr(soleil.alt)))\n",
    "    pt.plot([az], [90 - el], ls =\"\", marker= \"o\", c =\"blue\", \\\n",
    "    markersize =10)\n",
    "    # heure locale UTC +1 heures en hiver\n",
    "    if el > 0:\n",
    "        pt.text (az, 90 - el, \"%02d\"%(t+1), fontsize =10, \\\n",
    "        ha = 'left' , va = 'center')\n",
    "# nous limitons la distance zénithale à 90 degrés - horizon\n",
    "plt.set_rmax(90.0)\n",
    "# nous plaçons le nord en haut du graphique\n",
    "plt.set_theta_zero_location(\"N\")\n",
    "# ENGISTREZ LE GRAPHIQUE EN FORMAT PDF ET PNG\n",
    "plt.savefig(\"figs/mvtSoleil.pdf\"); plt.savefig (\"figs/mvtSoleil.png\")\n",
    "plt.show ()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Mouvement apparent du Soleil - le graphique\n",
    "<!-- dom:FIGURE: [figs/mvtSoleil.png, width=500 frac=0.9] -->\n",
    "<!-- begin figure -->\n",
    "\n",
    "<p></p>\n",
    "<img src=\"figs/mvtSoleil.png\" width=500>\n",
    "\n",
    "<!-- end figure -->\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "<!-- --- begin exercise --- -->\n",
    "\n",
    "## Exercise 1: Mouvement apparent du Soleil - région polaire\n",
    "\n",
    "Changer les coordonnées géographiques. Cette fois dans une ville proche de la région polaire et tracez le nouveau graphique. Que s'est-il passé et comment décrivez-vous le phénomène?\n",
    "\n",
    "<!-- --- end exercise --- -->\n",
    "\n",
    "\n",
    "## Mouvement rétrograde de Mars\n",
    "Dès l'Antiquité, il a été remarqué que le mouvement de certains objets dans le ciel est d'un caractère différent du trafic de la majorité (**étoiles fixes**). De tels objets ont été appelés étoiles errantes (**planètes**). Aujourd'hui, nous savons que errer sur les planètes a pour effet de placer leur mouvement en même temps que le mouvement de la Terre autour du Soleil. Nous pouvons retracer ce phénomène sur l'exemple de Mars.\n",
    "<!-- dom:FIGURE: [figs/retro_mars.png, width=500 frac=0.5] Projection depuis la Terre (en bleu) des mouvements de la planète extérieure (en rouge) sur la sphère des étoiles fixes. *Source: Wikipédia* -->\n",
    "<!-- begin figure -->\n",
    "\n",
    "<p>Projection depuis la Terre (en bleu) des mouvements de la planète extérieure (en rouge) sur la sphère des étoiles fixes. <em>Source: Wikipédia</em></p>\n",
    "<img src=\"figs/retro_mars.png\" width=500>\n",
    "\n",
    "<!-- end figure -->\n",
    "\n",
    "\n",
    "## Mouvement rétrograde de Mars - début du programme"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "# IMPORTATION\n",
    "import ephem as ep\n",
    "# deux fonctions supplémentaires du module datetime sont nécessaires\n",
    "from datetime import datetime , timedelta\n",
    "\n",
    "# OBSERVATEUR\n",
    "obs = ep.Observer()\n",
    "# COORDONNÉES DE TUNIS\n",
    "obs.lon, obs.lat, obs.elev = '10.08', '36.4', 100.0\n",
    "obs.name = \"SAT-TUNIS\"\n",
    "# MARS\n",
    "mr = ep.Mars()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Mouvement rétrograde de Mars - boucle principale"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "from pylab import *\n",
    "plt.figure(figsize=(10, 5))\n",
    "for i in range (0 , 181):\n",
    "    # nous changeons la date d'un jour pendant six mois\n",
    "    dt = datetime (2018, 5, 1) + timedelta(i)\n",
    "    ds = \"%d/%02d/%02d\"%(dt.year, dt.month, dt.day)\n",
    "    print(\" jour de l'année: \", i +1 , ds)\n",
    "    # fixer la date de l'observateur et calculer les coordonnées\n",
    "    obs.date = ds\n",
    "    mr.compute(obs)\n",
    "    ra = degrees(float(repr(mr.ra)))\n",
    "    de = degrees(float(repr(mr.dec)))\n",
    "    # on dessine des objets\n",
    "    plot([ra], [de], c = \"red\", marker = \"o\", alpha =.5)\n",
    "    # nous ajoutons une description de la date en moyenne tous les 10 jours\n",
    "    if (dt.day % 10) == 0: text(ra, de, ds, fontsize =8)\n",
    "\n",
    "# description du graphique\n",
    "xlabel(\"ascension droite \" + r\"$\\alpha$ (deg)\")\n",
    "ylabel(\" déclinaison \" + r\"$\\delta$ (deg)\")\n",
    "title(\"Mouvement retrograde de Mars - 6 mois en 2018 \\n\"+obs.name, fontweight='bold')\n",
    "savefig(\"../figs/retrogradeMars.pdf\"); savefig(\"../figs/retrogradeMars.png\")\n",
    "show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Mouvement rétrograde de Mars - le graphique\n",
    "<!-- dom:FIGURE: [figs/retrogradeMars1.png] -->\n",
    "<!-- begin figure -->\n",
    "\n",
    "<p></p>\n",
    "<img src=\"figs/retrogradeMars1.png\" >\n",
    "\n",
    "<!-- end figure -->\n",
    "\n",
    "\n",
    "## Mouvement rétrograde de Mars - changement du texte des axes"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "# conversion RA donné en degrés\n",
    "# sur les formats heure, minute et seconde\n",
    "def RAd2hms (x, loc):\n",
    "    h = x//15\n",
    "    m = int(((x - h * 15.0) / 15.0) * 60.0)\n",
    "    s = ((x - h *15 - m / 4.0) / 15.0) * 3600.0\n",
    "    return \"%02dh%02dm%02ds\"%(h, m, s)\n",
    "# changement de déclinaison donné en degrés\n",
    "# le format du degré, minute, second arc\n",
    "def DEd2dms (x , loc ):\n",
    "    d = int(fabs(x))\n",
    "    m = int((fabs(x) - d)*60)\n",
    "    s = (fabs(x) - d - m /60.0)*3600.0\n",
    "    if x <0: d = -1 * d\n",
    "    return \" %02dd%02dm%02ds\"%(d, m, s)\n",
    "\n",
    "# description du graphique\n",
    "xlabel(\"ascension droite \" + r\"$\\alpha$\")\n",
    "gca().xaxis.set_major_formatter(FuncFormatter(RAd2hms))\n",
    "ylabel(\" déclinaison \" + r\"$\\delta$\")\n",
    "gca().yaxis.set_major_formatter(FuncFormatter(DEd2dms))\n",
    "title(\"Mouvement retrograde de Mars - 6 mois en 2018 \\n\"+obs.name, fontweight='bold')\n",
    "\n",
    "savefig(\"../figs/retrogradeMars.pdf\"); savefig(\"../figs/retrogradeMars.png\")\n",
    "show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Mouvement rétrograde de Mars - le graphique\n",
    "<!-- dom:FIGURE: [figs/retrogradeMars.png] -->\n",
    "<!-- begin figure -->\n",
    "\n",
    "<p></p>\n",
    "<img src=\"figs/retrogradeMars.png\" >\n",
    "\n",
    "<!-- end figure -->\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "<!-- --- begin exercise --- -->\n",
    "\n",
    "## Exercise 2: Quand le prochain mouvement rétrograde de la planète Mars?\n",
    "\n",
    "Changez la période et trouvez le prochain mouvement rétrograde de la planète Mars.\n",
    "\n",
    "<!-- --- end exercise --- -->\n",
    "\n",
    "\n",
    "## Mouvement des lunes galiléennes - début du programme"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "# IMPORTATION\n",
    "import ephem as ep\n",
    "# NOUS CRÉONS LES OBJETS\n",
    "Io = ep.Io()\n",
    "Eu = ep.Europa()\n",
    "Ga = ep.Ganymede()\n",
    "Ca = ep.Callisto()\n",
    "# Créons des tableaux vide pour\n",
    "# SAUVEGARDER LES COORDONNÉES\n",
    "y = []\n",
    "xIo = []\n",
    "xEu = []\n",
    "xGa = []\n",
    "xCa = []"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Mouvement des lunes galiléennes - boucle principale"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "# pas de temps - heure\n",
    "dt = ep.hour\n",
    "# temps initial\n",
    "ts = ep.now()\n",
    "# heure actuelle\n",
    "tm = ts\n",
    "N=2*24\n",
    "for i in range(N):\n",
    "    # nous calculons des valeurs y\n",
    "    y.append((tm - ts)*24.0)\n",
    "    # nous calculons des valeurs x\n",
    "    Io.compute(tm)\n",
    "    Eu.compute(tm)\n",
    "    Ga.compute(tm)\n",
    "    Ca.compute(tm)\n",
    "    # nous ajoutons des calculs aux tableaux\n",
    "    xIo.append(Io.x)\n",
    "    xEu.append(Eu.x)\n",
    "    xGa.append(Ga.x)\n",
    "    xCa.append(Ca.x)\n",
    "    # on augmente le temps d'une heure\n",
    "    tm += dt"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Mouvement des lunes galiléennes - le graphique"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "from pylab import *\n",
    "fig1 = plt.figure()\n",
    "plot(xIo, y, marker =\"o\", label =\"Io\")\n",
    "plot(xEu, y, marker =\"o\", label =\"Europa\")\n",
    "plot(xGa, y, marker =\"o\", label =\"Ganimedes\")\n",
    "plot(xCa, y, marker =\"o\", label =\"Callisto\")\n",
    "plot(zeros(len(y)),y ,marker =r\"$\\mathcircled{J}$\", markersize =15,\n",
    "     label =\"Jupiter\",color =\"orange\", fillstyle= 'none')\n",
    "xlabel(u\"position par rapport à Jupiter\")\n",
    "ylabel(\"Heures à partir de (%s TU)\"% ts)\n",
    "ylim(0,N+3)\n",
    "title(u\"Mouvement des lunes galiléennes\")\n",
    "grid()\n",
    "legend(loc =1)\n",
    "\n",
    "tight_layout()\n",
    "savefig(\"../figs/mvtjov.pdf\"); savefig(\"../figs/mvtjov.png\")\n",
    "show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Mouvement des lunes galiléennes - le graphique\n",
    "<!-- dom:FIGURE: [figs/mvtjov.png] -->\n",
    "<!-- begin figure -->\n",
    "\n",
    "<p></p>\n",
    "<img src=\"figs/mvtjov.png\" >\n",
    "\n",
    "<!-- end figure -->\n",
    "\n",
    "\n",
    "## Détermination de l'éclipse solaire - début du programme"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "# IMPORTATION\n",
    "import ephem as ep\n",
    "# OBSERVATEUR\n",
    "obs = ep.Observer()\n",
    "obs.lon, obs.lat, obs.elev = '10.08', '36.4', 100.0\n",
    "obs.name = \"SAT-TUNIS\"\n",
    "# OBJETSNIS\n",
    "soleil = ep.Sun()\n",
    "lune = ep.Moon()\n",
    "# pas de temps - heure\n",
    "dt = ep.hour\n",
    "# temps initial\n",
    "#ts = ep.now()\n",
    "ts=ep.Date(\"2015-01-01 00:00:00\")\n",
    "# heure actuelle\n",
    "tm = ts"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Détermination de l'éclipse solaire - boucle principale\n",
    "Nous vérifions la séparation du soleil et de la lune toutes les heures pendant les 10 prochaines années."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "for i in range (365*24*10):\n",
    "    # nous fixons l'heure actuelle\n",
    "    obs.date = tm\n",
    "    # nous calculons les coordonnées\n",
    "    soleil.compute(obs)\n",
    "    lune.compute(obs)\n",
    "    # rayons\n",
    "    rs = soleil.radius\n",
    "    rl = lune.radius\n",
    "    # on calcule la distance angulaire\n",
    "    sp = ep.separation(soleil, lune)\n",
    "    # on vérifie si la somme des rayons sera inférieure\n",
    "    # à la séparation calculée\n",
    "    if sp < rs + rl :\n",
    "    # nous vérifions si le soleil sera au-dessus de l'horizon\n",
    "        if soleil.alt > 0.0:\n",
    "            print(\"Date de l'eclipse UT: \", ep.Date(tm), \"Separation: \", sp)\n",
    "    # on augmente le temps par pas d'une heure\n",
    "    tm += dt"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Détermination de l'éclipse solaire -\n",
    "Les dates de l'éclipse solaire planifiée visible de la Tunisie au cours des 10 prochaines années."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "        Date de l'eclipse UT:  2020/6/21 05:00:00 Separation:  0:30:50.0\n",
    "        Date de l'eclipse UT:  2022/10/25 10:00:00 Separation:  0:29:25.7\n",
    "        Date de l'eclipse UT:  2022/10/25 11:00:00 Separation:  0:30:51.9\n",
    "        Date de l'eclipse UT:  2025/3/29 11:00:00 Separation:  0:32:49.2\n",
    "        Date de l'eclipse UT:  2026/8/12 18:00:00 Separation:  0:20:53.8\n",
    "        Date de l'eclipse UT:  2027/8/2 08:00:00 Separation:  0:30:44.7\n",
    "        Date de l'eclipse UT:  2027/8/2 09:00:00 Separation:  0:04:33.3\n",
    "        Date de l'eclipse UT:  2027/8/2 10:00:00 Separation:  0:21:01.3\n",
    "        Date de l'eclipse UT:  2028/1/26 16:00:00 Separation:  0:26:09.8\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Phases d'une éclipse solaire - début du programme"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "# IMPORTATION\n",
    "from pylab import *\n",
    "import ephem as ep\n",
    "# OBSERVATEUR\n",
    "obs = ep.Observer()\n",
    "# TUNIS\n",
    "obs.lon, obs.lat, obs.elev = '10.08', '36.4', 100.0\n",
    "obs.name= \"SAT-TUNIS\"\n",
    "# CRÉER DES OBJETS\n",
    "soleil = ep.Sun()\n",
    "lune = ep.Moon()\n",
    "# intervalle de temps - 20 minutes\n",
    "dt = ep.hour/4.\n",
    "# TEMPS DE DÉBUT\n",
    "ts = ep.Date(\"2027-08-02 08:00:00\")\n",
    "obs.date = ts\n",
    "# nous calculons les coordonnées\n",
    "soleil.compute(obs)\n",
    "lune.compute(obs)\n",
    "rs = degrees(soleil.radius)\n",
    "rl = degrees(lune.radius )"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Phases d'une éclipse solaire - suite"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "# nous calculons les coordonnées\n",
    "soleil.compute(obs)\n",
    "lune.compute(obs)\n",
    "rs = degrees(soleil.radius)\n",
    "rl = degrees(lune.radius )\n",
    "\n",
    "# Nous créons un graphique en l'attribuant à un pl COMME variable\n",
    "fig=plt.figure(figsize=(6,5))\n",
    "pl = subplot(111, aspect =\"equal\")\n",
    "# titre du graphique avec date et heure\n",
    "pl.set_title (obs.name+\"\\n début en (TU): \"+str(ep.Date(ts)))\n",
    "# Nous nous plaçons le soleil dans le centre\n",
    "sc=Circle((0 ,0), rs, facecolor =\"yellow\",\n",
    "            edgecolor =\"red\", lw =2)\n",
    "\n",
    "pl.add_artist(sc)\n",
    "# les coordonnées du Soleil\n",
    "pl.text(0, rs+0.1, \"Az: %.1f, El: %.1f\"%(degrees(soleil.az), degrees(soleil.alt)),\n",
    "        ha='center', fontsize =14)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Phases d'une éclipse solaire - boucle principale"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "# Nous plaçons la Lune dans la figure\n",
    "for i in range(10):\n",
    "    print(\"time UT: \", ep.Date(ts))\n",
    "    obs.date = ts\n",
    "    # nous calculons les coordonnées\n",
    "    soleil.compute(obs)\n",
    "    lune.compute(obs)\n",
    "    # Nous calculons la différence de position\n",
    "    az = degrees(soleil.az - lune.az)\n",
    "    el = degrees(soleil.alt - lune.alt)\n",
    "    # dessiner et la position réelle en empillements d'image de Lune; le Soleil estau centre\n",
    "    kc = Circle((az , el), rl , facecolor =\"gray\",\n",
    "                edgecolor =\"black\", lw =2, alpha =0.3)\n",
    "    pl.add_artist(kc)\n",
    "    # augmenter le temps de 20 minutes\n",
    "    ts += dt\n",
    "\n",
    "pl.set_xlim (-1.0, 1.0)\n",
    "pl.set_ylim (-1.0, 1.0)\n",
    "pl.set_xlabel (\"degré\")\n",
    "pl. set_ylabel (\"degré\")\n",
    "plt.tight_layout()\n",
    "savefig(\"../figs/eclipse_sol_\" + str(ts) +\".pdf\"); savefig(\"../figs/eclipse_sol_\" + str(ts) +\".png\")\n",
    "show ()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Phases d'une éclipse solaire - le graphique\n",
    "<!-- dom:FIGURE: [figs/eclipse_sol.png] -->\n",
    "<!-- begin figure -->\n",
    "\n",
    "<p></p>\n",
    "<img src=\"figs/eclipse_sol.png\" >\n",
    "\n",
    "<!-- end figure -->\n",
    "\n",
    "\n",
    "## Conjonction de la lune et des planètes"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "# IMPORTOWANIE\n",
    "from pylab import *\n",
    "import ephem as ep\n",
    "# OBSERVATEUR\n",
    "obs = ep.Observer()\n",
    "# TUNIS\n",
    "obs.lon, obs.lat, obs.elev = '10.08', '36.4', 100.0\n",
    "obs.name= \"SAT-TUNIS\"\n",
    "# NOUS CRÉONS UN OBJET\n",
    "# on vérifie si c'est sous l'horizon\n",
    "soleil = ep.Sun()\n",
    "lune = ep.Moon()\n",
    "venus = ep.Venus()\n",
    "mars = ep.Mars()\n",
    "jupiter = ep.Jupiter()\n",
    "# pas de temps - heure\n",
    "dt = ep.hour\n",
    "# temps initial\n",
    "ts = ep.now()\n",
    "# heure actuelle\n",
    "tm = ts"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Conjonction de la lune et des planètes - boucle principale"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "# BOUCLE PRINCIPAL DU PROGRAMME\n",
    "for i in range (365*24*1):\n",
    "# nous fixons l'heure actuelle\n",
    "    obs.date = tm\n",
    "    # nous calculons des coordonnées\n",
    "    soleil.compute(obs)\n",
    "    lune.compute(obs)\n",
    "    venus.compute(obs)\n",
    "    mars.compute(obs)\n",
    "    jupiter.compute(obs)\n",
    "    # on calcule la séparation\n",
    "    s1 = ep.separation(venus , lune)\n",
    "    s2 = ep.separation(mars , lune)\n",
    "    s3 = ep.separation(jupiter , lune)\n",
    "    # la séparation doit être inférieure à 5 degrés\n",
    "    if degrees(s1) < 5:\n",
    "        # nous vérifions si la lune sera au-dessus de l'horizon\n",
    "        # et si le soleil est au-dessous de l'horizon\n",
    "        if degrees(lune.alt) > 5.0 and degrees(soleil.alt) < -5.0:\n",
    "            print(\"-------------------------------------------------------------\")\n",
    "            print(u\"précédente nouvelle lune , UT :\", ep.previous_new_moon(ep.Date(tm)))\n",
    "            print(u\"Vénus - Lune , UT :\", ep.Date(tm) ,\"séparation :\", s1)\n",
    "            print(u\"pos. Lune :\", lune.az ,\"El :\", lune.alt)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Conjonction de la lune et des planètes - boucle principale (suite)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "if degrees(s2) < 5:\n",
    "    if degrees(lune.alt) > 5.0 and degrees(soleil.alt) < -5.0:\n",
    "        print(\"------------------------------------------------------------------\")\n",
    "        print(u\"précédente nouvelle lune , UT :\", ep.previous_new_moon(ep.Date(tm)))\n",
    "        print(u\"Mars - Lune , UT :\", ep.Date(tm) ,\"séparation :\", s2)\n",
    "        print(u\"Pos. Lune, Az :\", lune.az ,\"El :\", lune.alt)\n",
    "if degrees(s3) < 5:\n",
    "    if degrees(lune.alt) > 5.0 and degrees(soleil.alt) < -5.0:\n",
    "        print(\"--------------------------------------------------------------\")\n",
    "        print(u\"précédente nouvelle lune , UT :\", ep.previous_new_moon(ep.Date(tm)))\n",
    "        print(u\"Jupiter - Lune , UT :\", ep.Date(tm) ,\"séparation :\", s3)\n",
    "        print(u\"Pos. Lune, Az :\", lune.az ,\"El :\", lune.alt)\n",
    "    # on augmente le temps d'une heure\n",
    "tm += dt"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Exemples de résultats de calculs:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "        --------------------------------------------------------------\n",
    "        précédente nouvelle lune , UT : 2019/1/6 01:28:11\n",
    "        Jupiter - Lune , UT : 2019/1/31 03:47:21 séparation : 3:09:07.3\n",
    "        Pos. Lune, Az : 122:58:36.9 El : 8:18:03.0\n",
    "        --------------------------------------------------------------\n",
    "        précédente nouvelle lune , UT : 2019/2/4 21:03:35\n",
    "        Vénus - Lune , UT : 2019/3/3 04:47:21 séparation : 4:07:18.5\n",
    "        pos. Lune : 121:01:33.3 El : 6:15:18.7\n",
    "        --------------------------------------------------------------\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Cartopy\n",
    "**Cartopy** est un package Python conçu pour le traitement des données géospatiales afin de produire des cartes et d’autres analyses de données géospatiales.\n",
    "\n",
    "**Installation de Cartopy:**\n",
    "\n",
    "Le moyen le plus simple d’installer **Cartopy** est **Conda**. Pour toutes les plateformes, l’installation de cartopy peut se faire avec:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "        conda install -c conda-forge cartopy\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Exemple simple:**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "%matplotlib inline\n",
    "\n",
    "import datetime\n",
    "import matplotlib.pyplot as plt\n",
    "import cartopy.crs as ccrs\n",
    "from cartopy.feature.nightshade import Nightshade\n",
    "fig = plt.figure(figsize=(10, 5))\n",
    "ax = fig.add_subplot(1, 1, 1, projection=ccrs.PlateCarree())\n",
    "date = datetime.datetime(2019, 1, 13, 11)\n",
    "ax.set_title('Night time shading for {}'.format(date))\n",
    "ax.stock_img()\n",
    "ax.add_feature(Nightshade(date, alpha=0.2))\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Graphique\n",
    "<!-- dom:FIGURE: [figs/cartopy1.png, width=500 frac=1.2] -->\n",
    "<!-- begin figure -->\n",
    "\n",
    "<p></p>\n",
    "<img src=\"figs/cartopy1.png\" width=500>\n",
    "\n",
    "<!-- end figure -->\n",
    "\n",
    "\n",
    "## Application: Eclipse totale du Soleil en 2027\n",
    "<!-- dom:FIGURE: [figs/eclipse-4659.jpg, width=500 frac=1.1] -->\n",
    "<!-- begin figure -->\n",
    "\n",
    "<p></p>\n",
    "<img src=\"figs/eclipse-4659.jpg\" width=500>\n",
    "\n",
    "<!-- end figure -->\n",
    "\n",
    "\n",
    "**Merci de votre attention!**"
   ]
  }
 ],
 "metadata": {},
 "nbformat": 4,
 "nbformat_minor": 2
}
