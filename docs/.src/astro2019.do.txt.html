<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span></span><span style="color: #000080; font-weight: bold">TITLE: Tutoriel: Apprendre l&#39;Astronomie avec Python</span>
<span style="color: #000080; font-weight: bold">AUTHOR:</span> Ahmed Ammar {copyright|CC BY} Email:ahmed.ammar@fst.utm.tn at Faculté des Sciences, Université de Tunis El Manar et Société Astronomique de Tunisie.
<span style="color: #000080; font-weight: bold">DATE:</span> 2019

<span style="color: #000080; font-weight: bold">TOC:</span> on
<span style="color: #8B008B; font-weight: bold">!split</span>
<span style="color: #000080; font-weight: bold">======= Python =======</span>
<span style="color: #CD5555">&quot;Python&quot;</span>: &quot;http://www.python.org/&quot; est un langage de programmation moderne de haut niveau, orienté objet et d&#39;usage général.

_Caractéristiques générales de Python_ :

* Langage simple:
  * facile à lire et à apprendre avec une syntaxe minimaliste.
* Langage concis et expressif:
  * moins de lignes de code
  * moins de bugs
  * plus facile à maintenir.

<span style="color: #8B008B; font-weight: bold">!split</span>
_Détails techniques_ :

* Typé dynamiquement:
  * Pas besoin de définir le type des variables, les arguments ou le type des fonctions.
* La gestion automatique de la mémoire:
  * Aucune nécessité d&#39;allouer explicitement et désallouer la mémoire pour les variables et les tableaux de données. Aucun bug de fuite de mémoire.
* Interprété:
  * Pas besoin de compiler le code. L&#39;interpréteur Python lit et exécute le code python directement.

<span style="color: #8B008B; font-weight: bold">!split</span>
_Avantages_ :

* Le principal avantage est la facilité de programmation, qui minimise le temps nécessaire pour développer, déboguer et maintenir le code.
* Langage bien conçu qui encourage les bonnes pratiques de programmation:
  * Modulaire et orientée objet, permet l&#39;encapsulation  et la réutilisation de code. Il en résulte souvent un code plus transparent, plus facile à améliorer et sans bug.
  * Documentation intégré avec le code.
* De nombreuses bibliothèques standards, et de nombreux packages add-on.

<span style="color: #8B008B; font-weight: bold">!split</span>
<span style="color: #658b00">FIGURE: [figs/python_easy.png, width=600 frac=0.6]</span>


<span style="color: #8B008B; font-weight: bold">!split</span>
<span style="color: #000080; font-weight: bold">======= Installation d&#39;un environnement Python scientifique =======</span>

<span style="color: #000080; font-weight: bold">===== Installation sur ordinateur =====</span>

<span style="color: #000080; font-weight: bold">=== Qu’est ce que Anaconda ? ===</span>

L’installation d’un environnement Python complet peut-être une vraie galère. Déjà, il faut télécharger Python et l’installer. Par la suite, télécharger un à un les packages dont on a besoin. Parfois, le nombre de ces librairies peut-être grand.

Par ailleurs, il faut s’assurer de la compatibilité entre les versions des différentes packages qu’on a à télécharger. Bref, ce n’est pas amusant.

<span style="color: #8B008B; font-weight: bold">!split</span>
<span style="color: #CD5555">&quot;Anaconda&quot;</span>: &quot;https://www.anaconda.com/download/&quot; est  une distribution Python. A son installation, Anaconda installera Python ainsi qu&#39;une multitude de packages (voir &quot;liste de packages anaconda&quot;: &quot;https://docs.anaconda.com/anaconda/packages/pkg-docs#python-3-6&quot;).  Cela nous évite de nous ruer dans les problèmes d’incompatibilités entre les différents packages.

Finalement, Anaconda propose un outil de gestion de packages appelé &quot;conda&quot;: &quot;https://conda.io/docs/&quot;. Ce dernier permettra de mettre à jour et installer facilement les librairies dont on aura besoin pour nos développements.

<span style="color: #8B008B; font-weight: bold">!split</span>
<span style="color: #000080; font-weight: bold">=== Préparer la formation: téléchargement d’Anaconda ===</span>

Nous demandons à tous les étudiants de télécharger Anaconda. Pour cela, il faut télécharger un installeur à partir de https://www.anaconda.com/download/, correspondant à votre système d’exploitation (Windows, Mac OS X, Linux). Il faut choisir entre 32 bits ou 64 bits (pour la version *Python 3*) selon que votre système d’exploitation est 32 bits ou 64 bits.
<span style="color: #8B008B; font-weight: bold">!split</span>

<span style="color: #658b00">FIGURE: [figs/AnacondaNavigator, width=600 frac=0.7] Interface graphique du navigateur Anaconda sur Windows</span>

<span style="color: #8B008B; font-weight: bold">!split</span>
<span style="color: #8B008B; font-weight: bold">!bnotice</span>
Anaconda installe plusieurs exécutables pour développer en Python dans le répertoire *anaconda/bin*, sans toujours créer des raccourcis sur le bureau ou dans un menu. Nous nous occuperons au tout début de la formation de créer des raccourcis pour pouvoir lancer l&#39;application web *Jupyter notebook*. Vous pouvez lancer le notebook depuis le navigateur Anaconda.
<span style="color: #8B008B; font-weight: bold">!enotice</span>


<span style="color: #8B008B; font-weight: bold">!split</span>
<span style="color: #000080; font-weight: bold">===== Installation sur smartphone =====</span>

<span style="color: #000080; font-weight: bold">=== Pydroid 3 - IDE éducatif pour Python 3 ===</span>

Pydroid 3 est l&#39;IDE éducatif Python 3 le plus simple et le plus puissant à utiliser pour Android.

Pydroid 3 fournit:

* Interpréteur Python 3.6 hors connexion: Internet n&#39;est pas nécessaire pour exécuter des programmes Python.
* Pip package manager et un référentiel personnalisé pour les packages de roues prédéfinis pour les bibliothèques scientifiques améliorées, tels que numpy, scipy, matplotlib, scikit-learn et jupyter.
* ...

<span style="color: #8B008B; font-weight: bold">!split</span>
<span style="color: #800080; font-weight: bold">__Installer et utiliser Pydroid 3 sur son smartphone:__</span>

Pydroid est une application Android que vous pouvez obtenir sur Google Play: URL: &quot;https://play.google.com/store/apps/details?id=ru.iiec.pydroid3&quot;

Les étapes suivantes, dans les figures ci-dessous, vous permettent d’utiliser le cahier Jupyter sur votre téléphone portable n’importe où et à tout moment pour vous entraîner au maximum et vous familiariser avec tous les exemples de programmation de ce cours.

<span style="color: #8B008B; font-weight: bold">!split</span>
_Phase installation:_

1. Installer Pydroid 3 depuis Google Play: URL:&quot;https://play.google.com/store/apps/details?id=ru.iiec.pydroid3&quot;

2. Ouvrez l&#39;application, sur le menu cliquez sur pip et allez à l&#39;onglet &quot;QUICK INSTALL&quot; pour obtenir les bibliothèques scientifiques nécessaires à ce cours.

3. Dans &quot;QUICK INSTALL&quot;, installer les packages *Jupyter* , *numpy* et *matplotlib*.

<span style="color: #658b00">FIGURE: [figs/pydroid3_1, width=600 frac=0.7] Pydroid 3: Phase installation</span>

<span style="color: #8B008B; font-weight: bold">!split</span>
_Phase utilisation:_

4. Retournez au menu et ouvrez le _terminal_.

5. Sur le terminal, entrez la commande suivante:

<span style="color: #8B008B; font-weight: bold">!bc</span> sys
jupyter notebook
<span style="color: #8B008B; font-weight: bold">!ec</span>

6. Jupyter s&#39;exécutera sur votre navigateur Web. Accédez au répertoire dans lequel vous avez des notebooks à ouvrir, à télécharger (bouton *upload*) ou à créer (bouton *New*).

7. Amusez-vous à travailler sur le notebook: créez du contenu, lancez et modifiez des exemples

<span style="color: #658b00">FIGURE: [figs/pydroid3_2, width=600 frac=0.7] Pydroid 3: Phase utilisation</span>

<span style="color: #8B008B; font-weight: bold">!split</span>
<span style="color: #000080; font-weight: bold">======= PyEphem =======</span>
Le module _PyEphem_ (URL:&quot;https://rhodesmill.org/pyephem/&quot;) vous permet d&#39;effectuer de nombreux calculs astronomiques professionnels. Vous pouvez l&#39;utiliser:
* calculer les positions du soleil, de la lune, des planètes et de leurs lunes.
* déterminer l&#39;emplacement actuel des astéroïdes, des comètes et des satellites artificiels (fournir des éléments orbitaux).
* déterminer le lever et le coucher du soleil d&#39;objets divers en fonction de la position de l&#39;observateur à la surface de la Terre.
* trouver dans quelle constellation l&#39;objet est.
* calculer la position de étoiles, galaxies, etc.

_PyEphem_ est basé sur des procédures écrites pour le programme _XEphem_ (URL:&quot;www.clearskyinstitute.com/xephem/&quot;), disponible depuis de nombreuses années pour les utilisateurs du système *Unix*.

<span style="color: #8B008B; font-weight: bold">!split</span>
<span style="color: #000080; font-weight: bold">===== Installation =====</span>
La version 3.7.6.0 est la version la plus récente de PyEphem.
<span style="color: #658b00">FIGURE: [figs/pyephem, width=500 frac=0.3]</span>
Le moyen le plus simple d’installer PyEphem sur un ordinateur Window, Linux ou Mac OS, après s’être assuré que la distribution Python _Anaconda_ est bien installée, est d&#39;utiliser la commande `pip`, comme ceci:
<span style="color: #8B008B; font-weight: bold">!bc</span> shell-t
$ pip install pyephem
<span style="color: #8B008B; font-weight: bold">!ec</span>
<span style="color: #8B008B; font-weight: bold">!split</span>
<span style="color: #000080; font-weight: bold">===== Importation de module et lieu de l&#39;observateur =====</span>
Le module _PyEphem_ est disponible sous le nom _ephem_ qui peut être modifié lors de l’importation par l&#39;alias _ep_ pour raccourcir la programmation.
<span style="color: #8B008B; font-weight: bold">!bc</span> pycod
import ephem as ep
<span style="color: #228B22">#OBSERVATEUR</span>
obs = ep.Observer()
<span style="color: #228B22"># nous créons une structure dans laquelle des données</span>
<span style="color: #228B22"># sur la position de l&#39;observateur seront stockées</span>
obs.lon = &quot;10.00&quot;
obs.lat = &quot;36.5&quot;
obs.name = &quot;SAT-Tunis&quot;
obs.elevation = 100.0
<span style="color: #8B008B; font-weight: bold">!ec</span>
Les fonctions et les structures du module `ephem ` sont appelées dans la fonction `ep.method()`. Tout d&#39;abord, nous définissons la position de l&#39;observateur. Pour ce faire, nous créons la structure appropriée (`structure = ep.Observer()`) et remplissons ses champs (`structure.champ = valeur`).

<span style="color: #8B008B; font-weight: bold">!split</span>
<span style="color: #000080; font-weight: bold">===== Objets célestes et leur localisation =====</span>
Tous les objets célestes importants tels que le Soleil, la Lune, les planètes et leurs lunes peuvent être créés par la structure de `fonction = ep.NomObjet()`.
<span style="color: #8B008B; font-weight: bold">!bc</span> pycod
<span style="color: #228B22"># Objets</span>
<span style="color: #228B22"># nous créons une structure dans laquelle les données seront stockées</span>
lune = ep.Moon()
<span style="color: #8B008B; font-weight: bold">!ec</span>
Après avoir créé l&#39;objet, nous pouvons calculer son emplacement actuel en fournissant des informations sur l&#39;observateur, situées dans la structure `obs` précédemment créée.
<span style="color: #8B008B; font-weight: bold">!bc</span> pycod
<span style="color: #228B22"># CALCULS</span>
<span style="color: #228B22"># on calcule la position actuelle de l&#39;objet</span>
<span style="color: #228B22"># pour l&#39;observateur créé plus tôt</span>
lune.compute(obs)
<span style="color: #8B008B; font-weight: bold">!ec</span>
Comme vous pouvez le constater, vous pouvez définir plusieurs observateurs différents et compter les coordonnées de l&#39;objet sélectionné pour différents endroits de la Terre. Cela peut être utile lors de la planification de campagnes d’observation menées par différents observatoires.

<span style="color: #8B008B; font-weight: bold">!split</span>
<span style="color: #000080; font-weight: bold">===== Lecture de coordonnées =====</span>

Les coordonnées calculées sont lues à partir des champs de structure d&#39;objet.
<span style="color: #8B008B; font-weight: bold">!bc</span> pycod
<span style="color: #228B22"># coordonnées calculées</span>
print(&quot;Position actuelle de la Lune&quot;)
print(&quot; ------------------------------ &quot;)
<span style="color: #228B22"># nous affichons l&#39;ascension droite et la déclinaison</span>
print(&quot;RA : &quot;, lune.ra)
print(&quot;Dec : &quot;, lune.dec)
<span style="color: #228B22"># nous affichons l&#39;azimut et l&#39;élévation</span>
print(&quot;--------------------------------&quot;)
print(&quot;Az : &quot;, lune.az)
print (&quot;El : &quot; , lune.alt)
<span style="color: #8B008B; font-weight: bold">!ec</span>
Les valeurs calculées sont données au format *_heures: minutes: secondes_* ou *_degrés: minutes: secondes d&#39;arc_* pour l&#39;heure actuelle UT sur époque 2000.
<span style="color: #8B008B; font-weight: bold">!bc</span>
Position actuelle de la Lune
 ------------------------------
RA :  6:18:27.81
Dec :  20:49:04.9
--------------------------------
Az :  197:06:32.3
El :  56:50:39.8
<span style="color: #8B008B; font-weight: bold">!ec</span>
<span style="color: #8B008B; font-weight: bold">!split</span>
<span style="color: #000080; font-weight: bold">===== Coordonnées en degrés =====</span>
Toutes les coordonnées calculées par les procédures du module _PyEphem_ sont données en _radians_. lorsque nous voulons écrire leur valeur, par exemple, les radians sont automatiquement convertis au format approprié (heures, minutes, secondes dans le cas d&#39;une ascension droite ou degrés, minutes, secondes d&#39;arc pour d&#39;autres coordonnées).

Si vous souhaitez utiliser des coordonnées calculées sur un graphique, il est utile de les convertir en degrés à l&#39;aide de la fonction degrés.

<span style="color: #8B008B; font-weight: bold">!bc</span> pycod
<span style="color: #228B22"># coordonnées azimutales en degrés sous forme d&#39;un nombre réel</span>
print(&quot; -------------------------------- &quot;)
print(&quot;Az (deg): &quot;, degrees(lune.az))
print(&quot;El (deg): &quot;, degrees(lune.alt))
<span style="color: #8B008B; font-weight: bold">!ec</span>
Azimut et élévation en degrés:
<span style="color: #8B008B; font-weight: bold">!bc</span>
--------------------------------
Az (deg):  207.85208210454263
El (deg):  55.334644372169485
<span style="color: #8B008B; font-weight: bold">!ec</span>

<span style="color: #8B008B; font-weight: bold">!split</span>
<span style="color: #000080; font-weight: bold">===== Date et heure =====</span>

Nous pouvons attribuer n&#39;importe quelle date et heure à chaque observateur:
<span style="color: #8B008B; font-weight: bold">!bc</span> pycod
<span style="color: #228B22"># PROPRE DATE ET HEURE TU</span>
obs.date = &quot;2019/01/13 10:00:00&quot;
<span style="color: #8B008B; font-weight: bold">!ec</span>
Il faut seulement se rappeler que les chiffres de la date sont séparés par le signe `/` et l&#39;heure par deux points.

<span style="color: #8B008B; font-weight: bold">!split</span>
<span style="color: #000080; font-weight: bold">===== Mouvement apparent du Soleil - le début du programme =====</span>
<span style="color: #8B008B; font-weight: bold">!bc</span> pycod
<span style="color: #228B22"># IMPORTATION</span>
from pylab import *
import ephem as ep
<span style="color: #228B22"># OBSERVATEUR</span>
obs = ep.Observer()
<span style="color: #228B22"># TUNIS</span>
obs.lon, obs.lat, obs.elev = &#39;10.08&#39;, &#39;36.4&#39;, 100.0
obs.name= &quot;SAT-TUNIS&quot;
<span style="color: #228B22"># OBJET</span>
soleil = ep.Sun()
<span style="color: #228B22"># TEMPS</span>
tm = linspace(0 , 24 , 25)
<span style="color: #228B22"># GRAPHIQUE</span>
pt = subplot(111 , polar= True )
<span style="color: #8B008B; font-weight: bold">!ec</span>
<span style="color: #8B008B; font-weight: bold">!split</span>
<span style="color: #000080; font-weight: bold">===== Mouvement apparent du Soleil - solstice d&#39;été =====</span>
<span style="color: #8B008B; font-weight: bold">!bc</span> pycod
<span style="color: #228B22"># BOUCLE PRINCIPALE</span>
for t in tm :
    # changement de temps
    obs.date = &quot;2014/06/21 %02 d :00:00 &quot;%t
    # on calcule les coordonnées
    sun.compute(obs)
    # coordonnées azimutales - azimut en radians
    az = float(repr(sun.az))
    el = degrees(float(repr(sun.alt)))
    # graphique - on change l&#39;élévation par une distance zénithale
    pt.plot([az], [90 - el], ls =&quot; &quot;, marker= &quot; o &quot;, c =&quot; yellow &quot;, \
    markersize =10)
    # heure locale UTC +2 heures en été
    if el &gt; 0:
        pt.text (az, 90 - el, &quot; %02 d &quot;%(t+2), fontsize =10, \
        ha = &#39;left&#39; , va = &#39;center&#39;)
<span style="color: #8B008B; font-weight: bold">!ec</span>
<span style="color: #8B008B; font-weight: bold">!split</span>
<span style="color: #000080; font-weight: bold">===== Mouvement apparent du Soleil - solstice d&#39;hiver =====</span>
<span style="color: #8B008B; font-weight: bold">!bc</span> pycod
    # TRANSFERT HIVERNAL - nous répétons les calculs &quot;en décembre&quot;
    obs.date = &quot;2014/12/22 %02d:00:00&quot; % t
    soleil.compute(obs)
    az = float(repr(soleil.az))
    el = degrees(float(repr(soleil.alt)))
    pt.plot([az], [90 - el], ls =&quot;&quot;, marker= &quot;o&quot;, c =&quot;blue&quot;, \
    markersize =10)
    # heure locale UTC +1 heures en hiver
    if el &gt; 0:
        pt.text (az, 90 - el, &quot;%02d&quot;%(t+1), fontsize =10, \
        ha = &#39;left&#39; , va = &#39;center&#39;)
<span style="color: #228B22"># nous limitons la distance zénithale à 90 degrés - horizon</span>
plt.set_rmax(90.0)
<span style="color: #228B22"># nous plaçons le nord en haut du graphique</span>
plt.set_theta_zero_location(&quot;N&quot;)
<span style="color: #228B22"># ENGISTREZ LE GRAPHIQUE EN FORMAT PDF ET PNG</span>
plt.savefig(&quot;figs/mvtSoleil.pdf&quot;); plt.savefig (&quot;figs/mvtSoleil.png&quot;)
plt.show ()
<span style="color: #8B008B; font-weight: bold">!ec</span>

<span style="color: #8B008B; font-weight: bold">!split</span>
<span style="color: #000080; font-weight: bold">===== Mouvement apparent du Soleil - le graphique =====</span>
<span style="color: #658b00">FIGURE: [figs/mvtSoleil, width=500 frac=0.9]</span>

<span style="color: #8B008B; font-weight: bold">!split</span>
<span style="color: #000080; font-weight: bold">===== Exercise: Mouvement apparent du Soleil - région polaire =====</span>
Changer les coordonnées géographiques. Cette fois dans une ville proche de la région polaire et tracez le nouveau graphique. Que s&#39;est-il passé et comment décrivez-vous le phénomène?

<span style="color: #8B008B; font-weight: bold">!split</span>
<span style="color: #000080; font-weight: bold">===== Mouvement rétrograde de Mars =====</span>
Dès l&#39;Antiquité, il a été remarqué que le mouvement de certains objets dans le ciel est d&#39;un caractère différent du trafic de la majorité (_étoiles fixes_). De tels objets ont été appelés étoiles errantes (_planètes_). Aujourd&#39;hui, nous savons que errer sur les planètes a pour effet de placer leur mouvement en même temps que le mouvement de la Terre autour du Soleil. Nous pouvons retracer ce phénomène sur l&#39;exemple de Mars.
<span style="color: #658b00">FIGURE: [figs/retro_mars, width=500 frac=0.5] Projection depuis la Terre (en bleu) des mouvements de la planète extérieure (en rouge) sur la sphère des étoiles fixes. *Source: Wikipédia*</span>

<span style="color: #8B008B; font-weight: bold">!split</span>
<span style="color: #000080; font-weight: bold">===== Mouvement rétrograde de Mars - début du programme =====</span>

<span style="color: #8B008B; font-weight: bold">!bc</span> pycod
<span style="color: #228B22"># IMPORTATION</span>
import ephem as ep
<span style="color: #228B22"># deux fonctions supplémentaires du module datetime sont nécessaires</span>
from datetime import datetime , timedelta

<span style="color: #228B22"># OBSERVATEUR</span>
obs = ep.Observer()
<span style="color: #228B22"># COORDONNÉES DE TUNIS</span>
obs.lon, obs.lat, obs.elev = &#39;10.08&#39;, &#39;36.4&#39;, 100.0
obs.name = &quot;SAT-TUNIS&quot;
<span style="color: #228B22"># MARS</span>
mr = ep.Mars()
<span style="color: #8B008B; font-weight: bold">!ec</span>

<span style="color: #8B008B; font-weight: bold">!split</span>
<span style="color: #000080; font-weight: bold">===== Mouvement rétrograde de Mars - boucle principale =====</span>
<span style="color: #8B008B; font-weight: bold">!bc</span> pycod
from pylab import *
plt.figure(figsize=(10, 5))
for i in range (0 , 181):
    # nous changeons la date d&#39;un jour pendant six mois
    dt = datetime (2018, 5, 1) + timedelta(i)
    ds = &quot;%d/%02d/%02d&quot;%(dt.year, dt.month, dt.day)
    print(&quot; jour de l&#39;année: &quot;, i +1 , ds)
    # fixer la date de l&#39;observateur et calculer les coordonnées
    obs.date = ds
    mr.compute(obs)
    ra = degrees(float(repr(mr.ra)))
    de = degrees(float(repr(mr.dec)))
    # on dessine des objets
    plot([ra], [de], c = &quot;red&quot;, marker = &quot;o&quot;, alpha =.5)
    # nous ajoutons une description de la date en moyenne tous les 10 jours
    if (dt.day % 10) == 0: text(ra, de, ds, fontsize =8)

<span style="color: #228B22"># description du graphique</span>
xlabel(&quot;ascension droite &quot; + r&quot;$\alpha$ (deg)&quot;)
ylabel(&quot; déclinaison &quot; + r&quot;$\delta$ (deg)&quot;)
title(&quot;Mouvement retrograde de Mars - 6 mois en 2018 \n&quot;+obs.name, fontweight=&#39;bold&#39;)
savefig(&quot;../figs/retrogradeMars.pdf&quot;); savefig(&quot;../figs/retrogradeMars.png&quot;)
show()
<span style="color: #8B008B; font-weight: bold">!ec</span>
<span style="color: #8B008B; font-weight: bold">!split</span>
<span style="color: #000080; font-weight: bold">===== Mouvement rétrograde de Mars - le graphique =====</span>
<span style="color: #658b00">FIGURE: [figs/retrogradeMars1]</span>

<span style="color: #8B008B; font-weight: bold">!split</span>
<span style="color: #000080; font-weight: bold">===== Mouvement rétrograde de Mars - changement du texte des axes =====</span>
<span style="color: #8B008B; font-weight: bold">!bc</span> pycod
<span style="color: #228B22"># conversion RA donné en degrés</span>
<span style="color: #228B22"># sur les formats heure, minute et seconde</span>
def RAd2hms (x, loc):
    h = x//15
    m = int(((x - h * 15.0) / 15.0) * 60.0)
    s = ((x - h *15 - m / 4.0) / 15.0) * 3600.0
    return &quot;%02dh%02dm%02ds&quot;%(h, m, s)
<span style="color: #228B22"># changement de déclinaison donné en degrés</span>
<span style="color: #228B22"># le format du degré, minute, second arc</span>
def DEd2dms (x , loc ):
    d = int(fabs(x))
    m = int((fabs(x) - d)*60)
    s = (fabs(x) - d - m /60.0)*3600.0
    if x &lt;0: d = -1 * d
    return &quot; %02dd%02dm%02ds&quot;%(d, m, s)

<span style="color: #228B22"># description du graphique</span>
xlabel(&quot;ascension droite &quot; + r&quot;$\alpha$&quot;)
gca().xaxis.set_major_formatter(FuncFormatter(RAd2hms))
ylabel(&quot; déclinaison &quot; + r&quot;$\delta$&quot;)
gca().yaxis.set_major_formatter(FuncFormatter(DEd2dms))
title(&quot;Mouvement retrograde de Mars - 6 mois en 2018 \n&quot;+obs.name, fontweight=&#39;bold&#39;)

savefig(&quot;../figs/retrogradeMars.pdf&quot;); savefig(&quot;../figs/retrogradeMars.png&quot;)
show()
<span style="color: #8B008B; font-weight: bold">!ec</span>

<span style="color: #8B008B; font-weight: bold">!split</span>
<span style="color: #000080; font-weight: bold">===== Mouvement rétrograde de Mars - le graphique =====</span>
<span style="color: #658b00">FIGURE: [figs/retrogradeMars]</span>

<span style="color: #8B008B; font-weight: bold">!split</span>
<span style="color: #000080; font-weight: bold">===== Exercise: Quand le prochain mouvement rétrograde de la planète Mars? =====</span>
Changez la période et trouvez le prochain mouvement rétrograde de la planète Mars.

<span style="color: #8B008B; font-weight: bold">!split</span>
<span style="color: #000080; font-weight: bold">===== Mouvement des lunes galiléennes - début du programme  =====</span>
<span style="color: #8B008B; font-weight: bold">!bc</span> pycod
<span style="color: #228B22"># IMPORTATION</span>
import ephem as ep
<span style="color: #228B22"># NOUS CRÉONS LES OBJETS</span>
Io = ep.Io()
Eu = ep.Europa()
Ga = ep.Ganymede()
Ca = ep.Callisto()
<span style="color: #228B22"># Créons des tableaux vide pour</span>
<span style="color: #228B22"># SAUVEGARDER LES COORDONNÉES</span>
y = []
xIo = []
xEu = []
xGa = []
xCa = []
<span style="color: #8B008B; font-weight: bold">!ec</span>

<span style="color: #8B008B; font-weight: bold">!split</span>
<span style="color: #000080; font-weight: bold">===== Mouvement des lunes galiléennes - boucle principale  =====</span>
<span style="color: #8B008B; font-weight: bold">!bc</span> pycod
<span style="color: #228B22"># pas de temps - heure</span>
dt = ep.hour
<span style="color: #228B22"># temps initial</span>
ts = ep.now()
<span style="color: #228B22"># heure actuelle</span>
tm = ts
N=2*24
for i in range(N):
    # nous calculons des valeurs y
    y.append((tm - ts)*24.0)
    # nous calculons des valeurs x
    Io.compute(tm)
    Eu.compute(tm)
    Ga.compute(tm)
    Ca.compute(tm)
    # nous ajoutons des calculs aux tableaux
    xIo.append(Io.x)
    xEu.append(Eu.x)
    xGa.append(Ga.x)
    xCa.append(Ca.x)
    # on augmente le temps d&#39;une heure
    tm += dt
<span style="color: #8B008B; font-weight: bold">!ec</span>


<span style="color: #8B008B; font-weight: bold">!split</span>
<span style="color: #000080; font-weight: bold">===== Mouvement des lunes galiléennes - le graphique  =====</span>
<span style="color: #8B008B; font-weight: bold">!bc</span> pycod
from pylab import *
fig1 = plt.figure()
plot(xIo, y, marker =&quot;o&quot;, label =&quot;Io&quot;)
plot(xEu, y, marker =&quot;o&quot;, label =&quot;Europa&quot;)
plot(xGa, y, marker =&quot;o&quot;, label =&quot;Ganimedes&quot;)
plot(xCa, y, marker =&quot;o&quot;, label =&quot;Callisto&quot;)
plot(zeros(len(y)),y ,marker =r&quot;$\mathcircled{J}$&quot;, markersize =15,
     label =&quot;Jupiter&quot;,color =&quot;orange&quot;, fillstyle= &#39;none&#39;)
xlabel(u&quot;position par rapport à Jupiter&quot;)
ylabel(&quot;Heures à partir de (%s TU)&quot;% ts)
ylim(0,N+3)
title(u&quot;Mouvement des lunes galiléennes&quot;)
grid()
legend(loc =1)

tight_layout()
savefig(&quot;../figs/mvtjov.pdf&quot;); savefig(&quot;../figs/mvtjov.png&quot;)
show()
<span style="color: #8B008B; font-weight: bold">!ec</span>
<span style="color: #8B008B; font-weight: bold">!split</span>
<span style="color: #000080; font-weight: bold">===== Mouvement des lunes galiléennes - le graphique =====</span>
<span style="color: #658b00">FIGURE: [figs/mvtjov]</span>

<span style="color: #8B008B; font-weight: bold">!split</span>
<span style="color: #000080; font-weight: bold">===== Détermination de l&#39;éclipse solaire - début du programme =====</span>
<span style="color: #8B008B; font-weight: bold">!bc</span> pycod
<span style="color: #228B22"># IMPORTATION</span>
import ephem as ep
<span style="color: #228B22"># OBSERVATEUR</span>
obs = ep.Observer()
obs.lon, obs.lat, obs.elev = &#39;10.08&#39;, &#39;36.4&#39;, 100.0
obs.name = &quot;SAT-TUNIS&quot;
<span style="color: #228B22"># OBJETSNIS</span>
soleil = ep.Sun()
lune = ep.Moon()
<span style="color: #228B22"># pas de temps - heure</span>
dt = ep.hour
<span style="color: #228B22"># temps initial</span>
<span style="color: #228B22">#ts = ep.now()</span>
ts=ep.Date(&quot;2015-01-01 00:00:00&quot;)
<span style="color: #228B22"># heure actuelle</span>
tm = ts
<span style="color: #8B008B; font-weight: bold">!ec</span>

<span style="color: #8B008B; font-weight: bold">!split</span>
<span style="color: #000080; font-weight: bold">===== Détermination de l&#39;éclipse solaire - boucle principale =====</span>
Nous vérifions la séparation du soleil et de la lune toutes les heures pendant les 10 prochaines années.
<span style="color: #8B008B; font-weight: bold">!bc</span> pycod
for i in range (365*24*10):
    # nous fixons l&#39;heure actuelle
    obs.date = tm
    # nous calculons les coordonnées
    soleil.compute(obs)
    lune.compute(obs)
    # rayons
    rs = soleil.radius
    rl = lune.radius
    # on calcule la distance angulaire
    sp = ep.separation(soleil, lune)
    # on vérifie si la somme des rayons sera inférieure
    # à la séparation calculée
    if sp &lt; rs + rl :
    # nous vérifions si le soleil sera au-dessus de l&#39;horizon
        if soleil.alt &gt; 0.0:
            print(&quot;Date de l&#39;eclipse UT: &quot;, ep.Date(tm), &quot;Separation: &quot;, sp)
    # on augmente le temps par pas d&#39;une heure
    tm += dt
<span style="color: #8B008B; font-weight: bold">!ec</span>

<span style="color: #8B008B; font-weight: bold">!split</span>
<span style="color: #000080; font-weight: bold">===== Détermination de l&#39;éclipse solaire -  =====</span>
Les dates de l&#39;éclipse solaire planifiée visible de la Tunisie au cours des 10 prochaines années.
<span style="color: #8B008B; font-weight: bold">!bc</span>
Date de l&#39;eclipse UT:  2020/6/21 05:00:00 Separation:  0:30:50.0
Date de l&#39;eclipse UT:  2022/10/25 10:00:00 Separation:  0:29:25.7
Date de l&#39;eclipse UT:  2022/10/25 11:00:00 Separation:  0:30:51.9
Date de l&#39;eclipse UT:  2025/3/29 11:00:00 Separation:  0:32:49.2
Date de l&#39;eclipse UT:  2026/8/12 18:00:00 Separation:  0:20:53.8
Date de l&#39;eclipse UT:  2027/8/2 08:00:00 Separation:  0:30:44.7
Date de l&#39;eclipse UT:  2027/8/2 09:00:00 Separation:  0:04:33.3
Date de l&#39;eclipse UT:  2027/8/2 10:00:00 Separation:  0:21:01.3
Date de l&#39;eclipse UT:  2028/1/26 16:00:00 Separation:  0:26:09.8
<span style="color: #8B008B; font-weight: bold">!ec</span>
<span style="color: #8B008B; font-weight: bold">!split</span>
<span style="color: #000080; font-weight: bold">===== Phases d&#39;une éclipse solaire - début du programme =====</span>
<span style="color: #8B008B; font-weight: bold">!bc</span> pycod
<span style="color: #228B22"># IMPORTATION</span>
from pylab import *
import ephem as ep
<span style="color: #228B22"># OBSERVATEUR</span>
obs = ep.Observer()
<span style="color: #228B22"># TUNIS</span>
obs.lon, obs.lat, obs.elev = &#39;10.08&#39;, &#39;36.4&#39;, 100.0
obs.name= &quot;SAT-TUNIS&quot;
<span style="color: #228B22"># CRÉER DES OBJETS</span>
soleil = ep.Sun()
lune = ep.Moon()
<span style="color: #228B22"># intervalle de temps - 20 minutes</span>
dt = ep.hour/4.
<span style="color: #228B22"># TEMPS DE DÉBUT</span>
ts = ep.Date(&quot;2027-08-02 08:00:00&quot;)
obs.date = ts
<span style="color: #228B22"># nous calculons les coordonnées</span>
soleil.compute(obs)
lune.compute(obs)
rs = degrees(soleil.radius)
rl = degrees(lune.radius )
<span style="color: #8B008B; font-weight: bold">!ec</span>

<span style="color: #8B008B; font-weight: bold">!split</span>
<span style="color: #000080; font-weight: bold">===== Phases d&#39;une éclipse solaire - suite =====</span>

<span style="color: #8B008B; font-weight: bold">!bc</span> pycod
<span style="color: #228B22"># nous calculons les coordonnées</span>
soleil.compute(obs)
lune.compute(obs)
rs = degrees(soleil.radius)
rl = degrees(lune.radius )

<span style="color: #228B22"># Nous créons un graphique en l&#39;attribuant à un pl COMME variable</span>
fig=plt.figure(figsize=(6,5))
pl = subplot(111, aspect =&quot;equal&quot;)
<span style="color: #228B22"># titre du graphique avec date et heure</span>
pl.set_title (obs.name+&quot;\n début en (TU): &quot;+str(ep.Date(ts)))
<span style="color: #228B22"># Nous nous plaçons le soleil dans le centre</span>
sc=Circle((0 ,0), rs, facecolor =&quot;yellow&quot;,
            edgecolor =&quot;red&quot;, lw =2)

pl.add_artist(sc)
<span style="color: #228B22"># les coordonnées du Soleil</span>
pl.text(0, rs+0.1, &quot;Az: %.1f, El: %.1f&quot;%(degrees(soleil.az), degrees(soleil.alt)),
        ha=&#39;center&#39;, fontsize =14)
<span style="color: #8B008B; font-weight: bold">!ec</span>

<span style="color: #8B008B; font-weight: bold">!split</span>
<span style="color: #000080; font-weight: bold">===== Phases d&#39;une éclipse solaire - boucle principale =====</span>

<span style="color: #8B008B; font-weight: bold">!bc</span> pycod
<span style="color: #228B22"># Nous plaçons la Lune dans la figure</span>
for i in range(10):
    print(&quot;time UT: &quot;, ep.Date(ts))
    obs.date = ts
    # nous calculons les coordonnées
    soleil.compute(obs)
    lune.compute(obs)
    # Nous calculons la différence de position
    az = degrees(soleil.az - lune.az)
    el = degrees(soleil.alt - lune.alt)
    # dessiner et la position réelle en empillements d&#39;image de Lune; le Soleil estau centre
    kc = Circle((az , el), rl , facecolor =&quot;gray&quot;,
                edgecolor =&quot;black&quot;, lw =2, alpha =0.3)
    pl.add_artist(kc)
    # augmenter le temps de 20 minutes
    ts += dt

pl.set_xlim (-1.0, 1.0)
pl.set_ylim (-1.0, 1.0)
pl.set_xlabel (&quot;degré&quot;)
pl. set_ylabel (&quot;degré&quot;)
plt.tight_layout()
savefig(&quot;../figs/eclipse_sol_&quot; + str(ts) +&quot;.pdf&quot;); savefig(&quot;../figs/eclipse_sol_&quot; + str(ts) +&quot;.png&quot;)
show ()
<span style="color: #8B008B; font-weight: bold">!ec</span>

<span style="color: #8B008B; font-weight: bold">!split</span>
<span style="color: #000080; font-weight: bold">===== Phases d&#39;une éclipse solaire - le graphique =====</span>
<span style="color: #658b00">FIGURE: [figs/eclipse_sol]</span>

<span style="color: #8B008B; font-weight: bold">!split</span>
<span style="color: #000080; font-weight: bold">===== Conjonction de la lune et des planètes =====</span>
<span style="color: #8B008B; font-weight: bold">!bc</span> pycod
<span style="color: #228B22"># IMPORTOWANIE</span>
from pylab import *
import ephem as ep
<span style="color: #228B22"># OBSERVATEUR</span>
obs = ep.Observer()
<span style="color: #228B22"># TUNIS</span>
obs.lon, obs.lat, obs.elev = &#39;10.08&#39;, &#39;36.4&#39;, 100.0
obs.name= &quot;SAT-TUNIS&quot;
<span style="color: #228B22"># NOUS CRÉONS UN OBJET</span>
<span style="color: #228B22"># on vérifie si c&#39;est sous l&#39;horizon</span>
soleil = ep.Sun()
lune = ep.Moon()
venus = ep.Venus()
mars = ep.Mars()
jupiter = ep.Jupiter()
<span style="color: #228B22"># pas de temps - heure</span>
dt = ep.hour
<span style="color: #228B22"># temps initial</span>
ts = ep.now()
<span style="color: #228B22"># heure actuelle</span>
tm = ts
<span style="color: #8B008B; font-weight: bold">!ec</span>

<span style="color: #8B008B; font-weight: bold">!split</span>
<span style="color: #000080; font-weight: bold">===== Conjonction de la lune et des planètes - boucle principale =====</span>
<span style="color: #8B008B; font-weight: bold">!bc</span> pycod
<span style="color: #228B22"># BOUCLE PRINCIPAL DU PROGRAMME</span>
for i in range (365*24*1):
<span style="color: #228B22"># nous fixons l&#39;heure actuelle</span>
    obs.date = tm
    # nous calculons des coordonnées
    soleil.compute(obs)
    lune.compute(obs)
    venus.compute(obs)
    mars.compute(obs)
    jupiter.compute(obs)
    # on calcule la séparation
    s1 = ep.separation(venus , lune)
    s2 = ep.separation(mars , lune)
    s3 = ep.separation(jupiter , lune)
    # la séparation doit être inférieure à 5 degrés
    if degrees(s1) &lt; 5:
        # nous vérifions si la lune sera au-dessus de l&#39;horizon
        # et si le soleil est au-dessous de l&#39;horizon
        if degrees(lune.alt) &gt; 5.0 and degrees(soleil.alt) &lt; -5.0:
            print(&quot;-------------------------------------------------------------&quot;)
            print(u&quot;précédente nouvelle lune , UT :&quot;, ep.previous_new_moon(ep.Date(tm)))
            print(u&quot;Vénus - Lune , UT :&quot;, ep.Date(tm) ,&quot;séparation :&quot;, s1)
            print(u&quot;pos. Lune :&quot;, lune.az ,&quot;El :&quot;, lune.alt)
<span style="color: #8B008B; font-weight: bold">!ec</span>

<span style="color: #8B008B; font-weight: bold">!split</span>
<span style="color: #000080; font-weight: bold">===== Conjonction de la lune et des planètes - boucle principale (suite) =====</span>
<span style="color: #8B008B; font-weight: bold">!bc</span> pycod
if degrees(s2) &lt; 5:
    if degrees(lune.alt) &gt; 5.0 and degrees(soleil.alt) &lt; -5.0:
        print(&quot;------------------------------------------------------------------&quot;)
        print(u&quot;précédente nouvelle lune , UT :&quot;, ep.previous_new_moon(ep.Date(tm)))
        print(u&quot;Mars - Lune , UT :&quot;, ep.Date(tm) ,&quot;séparation :&quot;, s2)
        print(u&quot;Pos. Lune, Az :&quot;, lune.az ,&quot;El :&quot;, lune.alt)
if degrees(s3) &lt; 5:
    if degrees(lune.alt) &gt; 5.0 and degrees(soleil.alt) &lt; -5.0:
        print(&quot;--------------------------------------------------------------&quot;)
        print(u&quot;précédente nouvelle lune , UT :&quot;, ep.previous_new_moon(ep.Date(tm)))
        print(u&quot;Jupiter - Lune , UT :&quot;, ep.Date(tm) ,&quot;séparation :&quot;, s3)
        print(u&quot;Pos. Lune, Az :&quot;, lune.az ,&quot;El :&quot;, lune.alt)
    # on augmente le temps d&#39;une heure
tm += dt
<span style="color: #8B008B; font-weight: bold">!ec</span>

Exemples de résultats de calculs:

<span style="color: #8B008B; font-weight: bold">!bc</span>
--------------------------------------------------------------
précédente nouvelle lune , UT : 2019/1/6 01:28:11
Jupiter - Lune , UT : 2019/1/31 03:47:21 séparation : 3:09:07.3
Pos. Lune, Az : 122:58:36.9 El : 8:18:03.0
--------------------------------------------------------------
précédente nouvelle lune , UT : 2019/2/4 21:03:35
Vénus - Lune , UT : 2019/3/3 04:47:21 séparation : 4:07:18.5
pos. Lune : 121:01:33.3 El : 6:15:18.7
--------------------------------------------------------------
<span style="color: #8B008B; font-weight: bold">!ec</span>
<span style="color: #8B008B; font-weight: bold">!split</span>
<span style="color: #000080; font-weight: bold">======= Cartopy =======</span>
_Cartopy_ est un package Python conçu pour le traitement des données géospatiales afin de produire des cartes et d’autres analyses de données géospatiales.

_Installation de Cartopy:_

Le moyen le plus simple d’installer _Cartopy_ est _Conda_. Pour toutes les plateformes, l’installation de cartopy peut se faire avec:
<span style="color: #8B008B; font-weight: bold">!bc</span> shell
conda install -c conda-forge cartopy
<span style="color: #8B008B; font-weight: bold">!ec</span>

_Exemple simple:_

<span style="color: #8B008B; font-weight: bold">!bc</span> pycod
import datetime
import matplotlib.pyplot as plt
import cartopy.crs as ccrs
from cartopy.feature.nightshade import Nightshade
fig = plt.figure(figsize=(10, 5))
ax = fig.add_subplot(1, 1, 1, projection=ccrs.PlateCarree())
date = datetime.datetime(2019, 1, 13, 11)
ax.set_title(&#39;Night time shading for {}&#39;.format(date))
ax.stock_img()
ax.add_feature(Nightshade(date, alpha=0.2))
plt.show()
<span style="color: #8B008B; font-weight: bold">!ec</span>

<span style="color: #8B008B; font-weight: bold">!split</span>
<span style="color: #000080; font-weight: bold">===== Graphique =====</span>
<span style="color: #658b00">FIGURE: [figs/cartopy1, width=500 frac=1.2]</span>

<span style="color: #8B008B; font-weight: bold">!split</span>
<span style="color: #000080; font-weight: bold">===== Application: Eclipse totale du Soleil en 2027 =====</span>
<span style="color: #658b00">FIGURE: [figs/eclipse-4659, width=500 frac=1.1]</span>

<span style="color: #8B008B; font-weight: bold">!split</span>
_Merci de votre attention!_
</pre></div>
